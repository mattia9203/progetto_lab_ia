# -*- coding: utf-8 -*-
"""Dataset.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16UhWHBFNPRL7eGG0vLZhPn7onvbVtQWO

#Creazione classe dataset
"""
import os
import re
import cv2
import random
import json
import torch
import numpy as np
import rasterio
import geopandas as gpd
from datetime import datetime
from torch.utils.data import Dataset, DataLoader
from rasterio.features import rasterize
from shapely.geometry import shape, mapping
from shapely.affinity import scale
from tqdm import tqdm

class Dataset(Dataset):
    def __init__(self, root, transform=None, patch_size=256, is_train=True):
        self.root = root
        self.transform = transform
        self.patch_size = patch_size
        self.is_train = is_train
        self.zones = self.load_zones()
        self.patches = self.generate_patches()

    def load_zones(self):
        zones = {}
        for zone in os.listdir(self.root):
            zone_path = os.path.join(self.root, zone)
            if os.path.isdir(zone_path):
                zones[zone] = self.load_images_and_labels(zone_path)
        return zones

    def load_images_and_labels(self, zone_path):
        image_label_pairs = []
        images_dir = os.path.join(zone_path, 'images_masked')
        labels_dir = os.path.join(zone_path, 'labels_match')
        if os.path.exists(images_dir) and os.path.exists(labels_dir):
            for image_file in os.listdir(images_dir):
                if image_file.endswith('.tif'):
                    image_path = os.path.join(images_dir, image_file)
                    label_file = os.path.splitext(image_file)[0] + '_Buildings.geojson'
                    label_path = os.path.join(labels_dir, label_file)
                    if os.path.exists(label_path):
                        date_str = re.search(r'\d{4}_\d{2}', image_file).group()
                        date = datetime.strptime(date_str, '%Y_%m')
                        image_label_pairs.append((image_path, label_path, date))
        image_label_pairs.sort(key=lambda x: x[2])
        return [(image_path, label_path) for image_path, label_path, date in image_label_pairs]
        
    def generate_images_masks(self,image_path1,image_path2,label_path1,label_path2):
        with rasterio.open(image_path1) as src1, rasterio.open(image_path2) as src2:
                image1 = src1.read().astype(np.float32)[:3, :, :]
                image2 = src2.read().astype(np.float32)[:3, :, :]
                out_shape = (src1.height, src1.width)

                if image1.shape[1:] != (1024, 1024):
                    image1 = self._resize_image(image1.transpose(1, 2, 0)).transpose(2, 0, 1)
                    out_shape = (image1.shape[1], image1.shape[2])
                if image2.shape[1:] != (1024, 1024):
                    image2 = self._resize_image(image2.transpose(1, 2, 0)).transpose(2, 0, 1)
                out_shape = (image2.shape[1], image2.shape[2])


                with open(label_path1) as label1, open(label_path2) as label2:
                    geojson1 = json.load(label1)
                    geojson2 = json.load(label2)


                mask1 = self.create_mask(geojson1, out_shape, src1.transform)
                mask2 = self.create_mask(geojson2, out_shape, src2.transform)


                image1_tensor = torch.from_numpy(image1)
                image2_tensor = torch.from_numpy(image2)
                if (image1_tensor.shape[0] != 3 and image1_tensor.shape[2] == 3):
                    image1_tensor = image1_tensor.permute(2,1,0)
                if (image2_tensor.shape[0] != 3 and image2_tensor.shape[2] == 3):
                    image2_tensor = image2_tensor.permute(2,1,0)
                if (image1_tensor.shape[0] != 3 and image1_tensor.shape[1] == 3):
                    image1_tensor = image1_tensor.permute(1,2,0)
                if (image2_tensor.shape[0] != 3 and image2_tensor.shape[1] == 3):
                    image2_tensor = image2_tensor.permute(1,2,0)
                images = torch.cat([image1_tensor, image2_tensor], dim=0)
                
                if not isinstance(mask1,np.ndarray):
                    mask1 = mask1.numpy()
                if not isinstance(mask2,np.ndarray):
                    mask2 = mask2.numpy()

                mask1_tensor = torch.from_numpy(mask1)
                mask2_tensor = torch.from_numpy(mask2)
                masks = torch.logical_xor(mask1_tensor, mask2_tensor).to(torch.uint8)
                
                if (images.shape[0] != 6 and images.shape[2]==6):
                    images.permute(2,1,0)
                if (images.shape[0] != 6 and images.shape[1]==6):
                    images.permute(1,2,0)
                
                image_patches, mask_patches = self.divide_into_patches(images, masks, self.patch_size)
                
        return image_patches,mask_patches
        

    def generate_patches(self):
        patches = []
        

        for zone in self.zones.keys():
            selected_pairs = set()  # Per tenere traccia delle coppie già selezionate
            num_images = len(self.zones[zone])
            indices = list(range(num_images))

            while len(selected_pairs) < (num_images // 2)-2:  # Assicurati di non selezionare più coppie di quante possibili
                i = random.choice(indices)
                max_interval = num_images - i - 1  # Numero massimo di mesi successivi disponibili
                if max_interval == 0:
                    continue  # Se non ci sono immagini successive disponibili, salta

                interval = random.randint(1, max_interval)
                j = i + interval
                if (i, j) not in selected_pairs:
                    selected_pairs.add((i, j))
                    image_path1, label_path1 = self.zones[zone][i]
                    image_path2, label_path2 = self.zones[zone][j]

                    images_patches, mask_patches = self.generate_images_masks(image_path1, image_path2, label_path1, label_path2)
                    patches.extend(zip(images_patches, mask_patches))
            

        return patches

    def __len__(self):
        return len(self.patches)

    def _resize_image(self, image, target_size=(1024, 1024)):  
        return cv2.resize(image, target_size, interpolation=cv2.INTER_LINEAR)           #ridimensiona l'immagine con l'interpolazione lineare, cioè calcola i nuovi pixel con una media ponderata dei pixel vicini

    def divide_into_patches(self, image, mask, patch_size,no_change_prob=0.3):
        patches = []
        mask_patches = []
        _, h, w = image.shape
        for i in range(0, h, patch_size):
            for j in range(0, w, patch_size):
                image_patch = image[:, i:i+patch_size, j:j+patch_size]
                mask_patch = mask[i:i+patch_size, j:j+patch_size]
                if image_patch.shape[1] == patch_size and image_patch.shape[2] == patch_size:
                    if np.sum(mask_patch.numpy() == 1) > 0 or (self.is_train and random.random() < no_change_prob) or not self.is_train:
                        patches.append(image_patch)
                        mask_patches.append(mask_patch)
        return patches, mask_patches

    def __getitem__(self, idx):
        image_patch, mask_patch = self.patches[idx]
        

        if self.transform:
            
            if (image_patch.shape[0] != 6 and image_patch.shape[2]==6):
                image_patch.permute(2,1,0)
            if (image_patch.shape[0] != 6 and image_patch.shape[1]==6):
                image_patch.permute(1,2,0)
                    
            if not isinstance(image_patch, np.ndarray):
                image_patch = image_patch.numpy()
                
            if not isinstance(mask_patch, np.ndarray):
                mask_patch = mask_patch.numpy()

            augmented = self.transform(image=np.transpose(image_patch, (1, 2, 0)), mask=mask_patch)
            image_patch = np.transpose(augmented['image'], (2, 1, 0))
            mask_patch=augmented['mask']
            
        return image_patch, mask_patch

    def create_mask(self, geojson, out_shape, transform):
        if 'features' in geojson and len(geojson['features']) > 0:
            gdf = gpd.GeoDataFrame.from_features(geojson['features'])
            if not gdf.empty and gdf.geometry.notnull().any():
                mask = rasterize([(geom, 1) for geom in gdf.geometry], out_shape=out_shape, transform=transform, fill=0, dtype='uint8')
            else:
                mask = np.zeros(out_shape, dtype='uint8')
        else:
            mask = np.zeros(out_shape, dtype='uint8')
            
        return mask
    def add_patches(self, patches):
        self.patches.extend(patches)