# -*- coding: utf-8 -*-
"""Dataset.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16UhWHBFNPRL7eGG0vLZhPn7onvbVtQWO

#Creazione classe dataset
"""
import os
import re
import cv2

import json
import torch
import numpy as np
import rasterio
import geopandas as gpd
from datetime import datetime
from torch.utils.data import Dataset, DataLoader
from rasterio.features import rasterize
from shapely.geometry import shape, mapping
from shapely.affinity import scale
from tqdm import tqdm

class Dataset(Dataset):
    def __init__(self, root, transform=None, patch_size=128, is_train=True):
        self.root = root
        self.transform = transform
        self.patch_size = patch_size
        self.is_train = is_train
        self.zones = self.load_zones()
        self.patches = self.generate_patches()

    def load_zones(self):
        zones = {}
        for zone in os.listdir(self.root):
            zone_path = os.path.join(self.root, zone)
            if os.path.isdir(zone_path):
                zones[zone] = self.load_images_and_labels(zone_path)
        return zones

    def load_images_and_labels(self, zone_path):
        image_label_pairs = []
        images_dir = os.path.join(zone_path, 'images_masked')
        labels_dir = os.path.join(zone_path, 'labels_match')
        if os.path.exists(images_dir) and os.path.exists(labels_dir):
            for image_file in os.listdir(images_dir):
                if image_file.endswith('.tif'):
                    image_path = os.path.join(images_dir, image_file)
                    label_file = os.path.splitext(image_file)[0] + '_Buildings.geojson'
                    label_path = os.path.join(labels_dir, label_file)
                    if os.path.exists(label_path):
                        date_str = re.search(r'\d{4}_\d{2}', image_file).group()
                        date = datetime.strptime(date_str, '%Y_%m')
                        image_label_pairs.append((image_path, label_path, date))
        image_label_pairs.sort(key=lambda x: x[2])
        return [(image_path, label_path) for image_path, label_path, date in image_label_pairs]
        
    def generate_images_masks(self,image_path1,image_path2,label_path1,label_path2):
        with rasterio.open(image_path1) as src1, rasterio.open(image_path2) as src2:
                image1 = src1.read().astype(np.float32)[:3, :, :]
                image2 = src2.read().astype(np.float32)[:3, :, :]
                out_shape = (src1.height, src1.width)

                if image1.shape[1:] != (1024, 1024):
                    image1 = self._resize_image(image1.transpose(1, 2, 0)).transpose(2, 0, 1)
                    out_shape = (image1.shape[1], image1.shape[2])
                if image2.shape[1:] != (1024, 1024):
                    image2 = self._resize_image(image2.transpose(1, 2, 0)).transpose(2, 0, 1)
                out_shape = (image2.shape[1], image2.shape[2])


                with open(label_path1) as label1, open(label_path2) as label2:
                    geojson1 = json.load(label1)
                    geojson2 = json.load(label2)


                mask1 = self.create_mask(geojson1, out_shape, src1.transform)
                mask2 = self.create_mask(geojson2, out_shape, src2.transform)

                if self.transform:
                    if not isinstance(image1, np.ndarray):
                        image1 = image1.numpy()
                    if not isinstance(image2, np.ndarray):
                        image2 = image2.numpy()

                    if not isinstance(mask1, np.ndarray):
                        mask1 = mask1.numpy()
                    if not isinstance(mask2, np.ndarray):
                        mask2 = mask2.numpy()

                    augmented1 = self.transform(image=np.transpose(image1, (1, 2, 0)), mask=mask1)
                    augmented2 = self.transform(image=np.transpose(image2, (1, 2, 0)), mask=mask2)
                    image1 = np.transpose(augmented1['image'], (2, 1, 0))
                    mask1 = augmented1['mask']
                    image2 = np.transpose(augmented2['image'], (2, 1, 0))
                    mask2 = augmented2['mask']
                    
                if not isinstance(image1,np.ndarray):
                    image1 = image1.numpy()
                if not isinstance(image2,np.ndarray):
                    image2 = image2.numpy()
                    

                image1_tensor = torch.from_numpy(image1)
                image2_tensor = torch.from_numpy(image2)
                if (image1_tensor.shape[0] != 3 and image1_tensor.shape[2] == 3):
                    image1_tensor = image1_tensor.permute(2,1,0)
                if (image2_tensor.shape[0] != 3 and image2_tensor.shape[2] == 3):
                    image2_tensor = image2_tensor.permute(2,1,0)
                if (image1_tensor.shape[0] != 3 and image1_tensor.shape[1] == 3):
                    image1_tensor = image1_tensor.permute(1,2,0)
                if (image2_tensor.shape[0] != 3 and image2_tensor.shape[1] == 3):
                    image2_tensor = image2_tensor.permute(1,2,0)
                images = torch.cat([image1_tensor, image2_tensor], dim=0)
                
                if not isinstance(mask1,np.ndarray):
                    mask1 = mask1.numpy()
                    #print(np.sum(mask1==1))
                if not isinstance(mask2,np.ndarray):
                    mask2 = mask2.numpy()
                    #print(np.sum(mask2==1))

                mask1_tensor = torch.from_numpy(mask1)
                mask2_tensor = torch.from_numpy(mask2)
                masks = torch.logical_xor(mask1_tensor, mask2_tensor).to(torch.uint8).numpy()
                
                if (images.shape[0] != 6 and images.shape[2]==6):
                    images.permute(2,1,0)
                if (images.shape[0] != 6 and images.shape[1]==6):
                    images.permute(1,2,0)
                
                image_patches, mask_patches = self.divide_into_patches(images, masks, self.patch_size)
                #patches.extend(zip(image_patches, mask_patches))

        return image_patches,mask_patches
        

    def generate_patches(self):
        patches = []
        for zone in self.zones.keys():
            if self.is_train == True:
                for i in range(0,len(self.zones[zone])-1,4):
                    image_path1, label_path1 = self.zones[zone][i]
                    if (i+4 < len(self.zones[zone])):
                        image_path2, label_path2 = self.zones[zone][i+4]
                    else:
                        image_path2, label_path2 = self.zones[zone][i+1]
                        
                    images_patches,mask_patches = self.generate_images_masks(image_path1,image_path2,label_path1,label_path2)
                    patches.extend(zip(images_patches, mask_patches))

            else:
                image_path1, label_path1 = self.zones[zone][0]
                image_path2, label_path2 = self.zones[zone][-1]

                    
                images_patches,mask_patches = self.generate_images_masks(image_path1,image_path2,label_path1,label_path2)
                patches.extend(zip(images_patches, mask_patches))
        return patches


    def __len__(self):
        return len(self.patches)

    def _resize_image(self, image, target_size=(1024, 1024)):
        return cv2.resize(image, target_size, interpolation=cv2.INTER_LINEAR)

    def resize_image(self, image, new_shape, src_crs, dst_crs):
        resized_image = np.zeros((image.shape[0], new_shape[0], new_shape[1]), dtype=np.float32)
        for i in range(image.shape[0]):
            resized_image[i] = rasterio.warp.reproject(
                source=image[i],
                destination=np.empty(new_shape, dtype=np.float32),
                src_transform=rasterio.transform.from_bounds(0, 0, image.shape[2], image.shape[1], image.shape[2], image.shape[1]),
                dst_transform=rasterio.transform.from_bounds(0, 0, new_shape[1], new_shape[0], new_shape[1], new_shape[0]),
                src_crs=src_crs,
                dst_crs=dst_crs,
                resampling=Resampling.bilinear
            )[0]
        return resized_image

    def resize_geojson(self, geojson, scale_factor):
        for feature in geojson['features']:
            geom = shape(feature['geometry'])
            scaled_geom = scale(geom, xfact=scale_factor, yfact=scale_factor)
            feature['geometry'] = mapping(scaled_geom)
        return geojson

    def divide_into_patches(self, image, mask, patch_size):
        patches = []
        mask_patches = []
        _, h, w = image.shape
        for i in range(0, h, patch_size):
            for j in range(0, w, patch_size):
                image_patch = image[:, i:i+patch_size, j:j+patch_size]
                mask_patch = mask[i:i+patch_size, j:j+patch_size]
                if image_patch.shape[1] == patch_size and image_patch.shape[2] == patch_size:
                  if np.sum(mask_patch==1)>0 or self.is_train == False:
                    patches.append(image_patch)
                    mask_patches.append(mask_patch)
        return patches, mask_patches

    def __getitem__(self, idx):
        image_patch, mask_patch = self.patches[idx]
        return image_patch, mask_patch

    def create_mask(self, geojson, out_shape, transform):
        if 'features' in geojson and len(geojson['features']) > 0:
            gdf = gpd.GeoDataFrame.from_features(geojson['features'])
            if not gdf.empty and gdf.geometry.notnull().any():
                mask = rasterize([(geom, 1) for geom in gdf.geometry], out_shape=out_shape, transform=transform, fill=0, dtype='uint8')
            else:
                mask = np.zeros(out_shape, dtype='uint8')
        else:
            mask = np.zeros(out_shape, dtype='uint8')
        return mask
