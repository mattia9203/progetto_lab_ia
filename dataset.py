# -*- coding: utf-8 -*-
"""Dataset.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16UhWHBFNPRL7eGG0vLZhPn7onvbVtQWO

#Creazione classe dataset
"""

import torch
import numpy as np
import pandas as pd
import fiona
import os
import cv2


import rasterio
import geopandas as gpd
import matplotlib.pyplot as plt


from torch.utils.data import Dataset
import json
from shapely.geometry import shape
from rasterio.features import rasterize

from torch.utils.data import Dataset
import json
from shapely.geometry import shape
from rasterio.features import rasterize
from datetime import datetime
import re

class Dataset(Dataset):
  def __init__(self,root,transform = None):
    self.root = root  #directory radice
    self.transform = transform
    self.zones = self.load_zones()


  def load_zones(self):
    zones = {}       #dizionario dove ad ogni chiave corrispondono
    #itero attraverso le cartelle per trovare percorsi delle immagini
    for zone in os.listdir(self.root):
      zone_path = os.path.join(self.root,zone)
      if os.path.isdir(zone_path):
        zones[zone] = self.load_images_and_labels(zone_path)
    return zones

  def load_images_and_labels(self,zone_path):
    image_label_pairs = []
    if os.path.isdir(zone_path):
      images_dir = os.path.join(zone_path, 'images_masked')     #directory con immagini
      labels_dir = os.path.join(zone_path, 'labels_match')      #directory con labels
      if os.path.exists(images_dir) and os.path.exists(labels_dir):
        for image_file in os.listdir(images_dir):
          if (image_file.endswith('.tif')):
            image_path = os.path.join(images_dir,image_file)
            label_file = os.path.splitext(image_file)[0] + '_Buildings.geojson'
            label_path = os.path.join(labels_dir,label_file)

            if os.path.exists(label_path):

                date_str = re.search(r'\d{4}_\d{2}', image_file).group()
                date = datetime.strptime(date_str, '%Y_%m')
                image_label_pairs.append((image_path, label_path, date))

              #image_label_pairs.append((image_path,label_path))

    image_label_pairs.sort(key=lambda x: x[2])
    image_label_pairs = [(image_path, label_path) for image_path, label_path, date in image_label_pairs]
    
    return image_label_pairs


  def __len__(self):
    return len(list(self.zones.keys()))


  def resize_image(self, image, target_size=(1024, 1024)):
    return cv2.resize(image, target_size, interpolation=cv2.INTER_LINEAR)



  def __getitem__(self,idx):

    if isinstance(idx,list):
        idx = idx[0]

    zone_keys = list(self.zones.keys())
    zone = zone_keys[idx]

    image_path1,label_path1 = self.zones[zone][0]
    image_path2,label_path2 = self.zones[zone][-1]

    with rasterio.open(image_path1) as src1, rasterio.open(image_path2) as src2:
      image1 = src1.read().astype(np.float32)[:3,:,:]
      image2 = src2.read().astype(np.float32)[:3,:,:]
      out_shape = (src1.height, src1.width)

      if image1.shape[1:] != (1024, 1024):
        image1 = self.resize_image(image1.transpose(1, 2, 0)).transpose(2, 0, 1)
        out_shape = (image1.shape[1], image1.shape[2])
      if image2.shape[1:] != (1024, 1024):
        image2 = self.resize_image(image2.transpose(1, 2, 0)).transpose(2, 0, 1)
        out_shape = (image2.shape[1], image2.shape[2])

      with open(label_path1) as label1, open(label_path2) as label2:
        geojson1 = json.load(label1)
        geojson2 = json.load(label2)

      mask1 = self.create_mask(geojson1, out_shape, src1.transform)
      mask2 = self.create_mask(geojson2, out_shape, src2.transform)

     
      if self.transform:
        if not isinstance(image1,np.ndarray):
            image1 = image1.numpy()
        if not isinstance(image2,np.ndarray):
            image2 = image2.numpy()
            
        if not isinstance(mask1,np.ndarray):
            mask1 = mask1.numpy()
        if not isinstance(mask2,np.ndarray):
            mask2 = mask2.numpy()
      
        augmented1 = self.transform(image=np.transpose(image1,(1,2,0)), mask=mask1)
        augmented2 = self.transform(image=np.transpose(image2,(1,2,0)), mask=mask2)
        image1 = np.transpose(augmented1['image'],(2,1,0))
        mask1 = augmented1['mask']
        image2 = np.transpose(augmented2['image'],(2,1,0))
        mask2 = augmented2['mask']

    if not isinstance(image1,np.ndarray):
      image1 = image1.numpy()
    if not isinstance(image2,np.ndarray):
      image2 = image2.numpy()

    image1_tensor = torch.from_numpy(image1)
    image2_tensor = torch.from_numpy(image2)
    images = torch.cat([image1_tensor,image2_tensor],dim=0).numpy()

    if not isinstance(mask1,np.ndarray):
      mask1 = mask1.numpy()
    if not isinstance(mask2,np.ndarray):
      mask2 = mask2.numpy()

    mask1_tensor = torch.from_numpy(mask1)
    mask2_tensor = torch.from_numpy(mask2)
    masks = torch.logical_xor(mask1_tensor, mask2_tensor).to(torch.uint8).numpy()

    return images, masks


  def create_mask(self, geojson, out_shape, transform):
        if 'features' in geojson and len(geojson['features']) > 0:
            gdf = gpd.GeoDataFrame.from_features(geojson['features'])
            if not gdf.empty and gdf.geometry.notnull().any():
                mask = rasterize([(geom, 1) for geom in gdf.geometry], out_shape=out_shape, transform=transform, fill=0, dtype='uint8')
            else:
                mask = np.zeros(out_shape, dtype='uint8')
        else:
            mask = np.zeros(out_shape, dtype='uint8')
        return mask


